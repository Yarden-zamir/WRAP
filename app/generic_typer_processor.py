#!/usr/bin/env python3.11
import functools
import importlib.util
import shutil
from inspect import isfunction, isclass, getmembers, getmodule
from os import system
from pathlib import Path

import typer


def _get_all_functions_in_module(module, allow_imports=False):  # should this be get all functions in class?
    module_of_class = getmodule(module)
    return [fun for fun in getmembers(module, isfunction) if
            not fun[0].startswith("_") and not fun[1].__module__.startswith("builtins")
            and (allow_imports or getmodule(fun[1]) == module_of_class or not getmodule(fun[1]))]


def _get_all_classes_in_module(module, allow_imports=False):
    return [cls for cls in getmembers(module, isclass) if
            not cls[0].startswith("_") and
            any(_get_all_functions_in_module(cls[1], allow_imports=allow_imports)) and
            (allow_imports or getmodule(cls[1]) == module or not getmodule(cls[1]))]


def _call_class(command):
    app = typer.Typer(name=command.__name__, no_args_is_help=True)

    functions = _get_all_functions_in_module(command)
    [app.command()(convert_return_to_print(function[-1])) for function in functions]
    # TODO add support for infinite nesting of classes and functions
    app()


def convert_return_to_print(func):
    @functools.wraps(func)
    def wrapper(*func_args, **func_kwargs):
        retval = func(*func_args, **func_kwargs)
        print(retval) if retval else None
        return retval

    return wrapper


def _call_function(command):
    app = typer.Typer(name=command.__name__, no_args_is_help=True, chain=True)
    app.command()(convert_return_to_print(command))
    app()


def call(command):
    if isfunction(command):
        _call_function(command)
    elif isclass(command):
        _call_class(command)


class generic_typer_processor:

    @staticmethod
    def get_input_formats():
        return "py"

    @staticmethod
    def get_output_formats():
        return "cli"

    def gen(file, output_path, debug_mode: bool = False):
        print(f"Loading {file} and writing to {output_path}") if debug_mode else None
        print(f"Reading file {file}") if debug_mode else None

        # import file as module

        spec = importlib.util.spec_from_file_location("module.name", file)
        foo = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(foo)

        # get all functions in module
        functions = _get_all_functions_in_module(foo)
        # get all classes in module
        classes = _get_all_classes_in_module(foo)

        wrappables = functions + classes
        print(f"Functions that are wrappable {functions}") if debug_mode else None
        print(f"Classes that are wrappable {classes}") if debug_mode else None

        # write file for each function or class
        # for cls in classes:
        #     pass
        for function in wrappables:
            function_name = function[0]
            print(f"{function:}") if debug_mode else None
            Path(output_path).mkdir(parents=True, exist_ok=True)
            processor_name = "generic_typer_processor"
            with open(f"{output_path}/{function_name}", "w") as f:
                f.write(
                    f"""#!/usr/bin/env python3.11
# This file was generated by WRAP
from sys import path
# add your module to path
path.append("{Path(file).parent}") 
# add this file to path
path.append("{Path(__file__).parent}")
path.append("{shutil.which(f'{processor_name}.py')}")
from {file.split('/')[-1].removesuffix(".py")} import *
from {f'{processor_name}'} import call

value = call({function_name})
"""
                )

            # chmod
            system(f"chmod +x {output_path}/{function_name}")


if __name__ == "__main__":
    call(generic_typer_processor)
