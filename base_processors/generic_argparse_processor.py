#!/usr/bin/env python3

import inspect
import shutil
import sys
import importlib.util
from os import system, getenv
from pathlib import Path
import inspect
import argparse

try:
    import argcomplete
except:
    pass


def generic_argparse_processor(file, output_path, debug_mode: bool = False):
    print(f"Loading {file} and writing to {output_path}") if debug_mode else None
    print(f"Reading file {file}") if debug_mode else None

    # import file as module

    spec = importlib.util.spec_from_file_location("module.name", file)
    foo = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(foo)

    # get all functions in module
    functions = [fun for fun in inspect.getmembers(foo, inspect.isfunction) if
                 not fun[0].startswith("_") and not fun[1].__module__.startswith("builtins")]

    # get all classes in module
    classes = [cls for cls in inspect.getmembers(foo, inspect.isclass)]

    wrappables = functions + classes
    print(functions) if debug_mode else None
    print(classes) if debug_mode else None

    # write file for each function or class
    # for cls in classes:
    #     pass
    for function in wrappables:
        function_name = function[0]
        print(function) if debug_mode else None
        Path(output_path).mkdir(parents=True, exist_ok=True)
        with open(f"{output_path}/{function_name}", "w") as f:
            f.write(
                f"""#!/usr/bin/env python3
# This file was generated by WRAP
from sys import path
# add your module to path
path.append("{Path(file).parent}") 
# add this file to path
path.append("{Path(__file__).parent}")
path.append("{shutil.which('wrap_generic_argparse_processor.py')}")
from {file.split('/')[-1].removesuffix(".py")} import *
from generic_argparse_processor import call

value = call({function_name})
if value: print(value)
"""
            )

        # chmod
        system(f"chmod +x {output_path}/{function_name}")


def _help(function, param):
    default = f"(default: {param.default})" if param.default != inspect.Parameter.empty else ""
    function_doc = [doc for doc in function.__doc__.split(":param") if param.name in doc] if function.__doc__ else []
    doc_string = function_doc[0].split(":")[1].strip() if len(function_doc) > 1 else ""
    return f"{doc_string} {default}"


def _type(param, to_string=False):
    t = param.annotation if param.annotation != inspect.Parameter.empty else type(
        param.default) if param.default != inspect.Parameter.empty else str
    return t.__name__ if to_string else t


# bool.__name__


def _is_first_parameter(param, function):
    return param.name == list(inspect.signature(function).parameters.keys())[
        0] if len(inspect.signature(function).parameters.keys()) > 0 else False
def _is_positional(param, function):
    return _is_first_parameter(param, function) or param.default == inspect.Parameter.empty

def _required(param, function):
    return True if \
        param.default == inspect.Parameter.empty and not (
                _is_first_parameter(param, function) or "**" not in str(function.__name__)) else False


def _call_function(function):
    parser = argparse.ArgumentParser(prog=function.__name__, description=function.__doc__)
    for param in inspect.signature(function).parameters.values():
        # if first argument then add it as positional
        if _is_positional(param, function):
            parser.add_argument(
                f"{param.name}",
                default=param.default if param.default != inspect.Parameter.empty else None,
                type=_type(param),
                nargs=argparse.OPTIONAL if not _required(param, function) else argparse.ZERO_OR_MORE,
                help=_help(function, param),
                metavar=f"{param.name} {_type(param, to_string=True)}"
            )
        else:
            parser.add_argument(
                f"--{param.name}",
                default=param.default if param.default != inspect.Parameter.empty else None,
                type=_type(param),
                required=_required(param, function),
                help=_help(function, param),
                metavar=_type(param, to_string=True)
            )

    try:
        argcomplete.autocomplete(parser)
    except NameError:
        pass
    args = parser.parse_args()
    # remove inspect empty args from dict
    a = vars(args)
    # print(a)
    args = vars(args)
    args = {k: v for k, v in args.items() if v is not inspect.Parameter.empty and v is not None}
    return function(**args)

def _call_class(cls):
    # using subparsers
    parser = argparse.ArgumentParser(prog=cls.__name__, description=cls.__doc__)
    subparsers = parser.add_subparsers(help='sub-command help')
    for method in [method for method in dir(cls) if method.startswith('__') is False]:
        method = getattr(cls, method)
        subparser = subparsers.add_parser(method.__name__, help=method.__doc__)
        for param in inspect.signature(method).parameters.values():
            # if first argument then add it as positional
            if _is_positional(param, method):
                subparser.add_argument(
                    f"{param.name}",
                    default=param.default if param.default != inspect.Parameter.empty else None,
                    type=_type(param),
                    nargs=argparse.OPTIONAL if not _required(param, method) else argparse.ZERO_OR_MORE,
                    help=_help(method, param),
                    metavar=f"{param.name} {_type(param, to_string=True)}"
                )
            else:
                subparser.add_argument(
                    f"--{param.name}",
                    default=param.default if param.default != inspect.Parameter.empty else None,
                    type=_type(param),
                    required=_required(param, method),
                    help=_help(method, param),
                    metavar=_type(param, to_string=True)
                )
        subparser.set_defaults(func=method)

    try:
        argcomplete.autocomplete(parser)
    except NameError:
        pass

    args = parser.parse_args()
    args = vars(args)
    args = {k: v for k, v in args.items() if v is not inspect.Parameter.empty and v is not None}
    # remove func from args
    func = args["func"] if "func" in args else None
    args.pop("func", None)
    return func(**args) if func else parser.print_help()

def call(command):
    if inspect.isfunction(command): _call_function(command)
    elif inspect.isclass(command): _call_class(command)

if __name__ == "__main__":
    call(generic_argparse_processor)
