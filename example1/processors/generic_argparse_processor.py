#!/usr/bin/env python3

import inspect
import sys
import importlib.util
from os import system, getenv
from pathlib import Path
import inspect
import argparse

try:
    import argcomplete
except:
    pass


def generic_argparse_processor(file, output_path, debug_mode: bool = False):
    print(f"Loading {file} and writing to {output_path}") if debug_mode else None
    print(f"Reading file {file}") if debug_mode else None

    # import file as module

    spec = importlib.util.spec_from_file_location("module.name", file)
    foo = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(foo)

    # get all functions in module
    functions = [fun for fun in inspect.getmembers(foo, inspect.isfunction) if
                 not fun[0].startswith("_") and not fun[1].__module__.startswith("builtins")]

    print(functions) if debug_mode else None

    # write sh file for each function
    for function in functions:
        function_name = function[0]
        print(function) if debug_mode else None
        Path(output_path).mkdir(parents=True, exist_ok=True)
        with open(f"{output_path}/{function_name}", "w") as f:
            f.write(
                f"""#!/usr/bin/env python3
# This file was generated by WRAP
from sys import path
# add your module to path
path.append("{Path(file).parent}") 
# add this file to path
path.append("{Path(__file__).parent}")
from {file.split('/')[-1].removesuffix(".py")} import *
from generic_argparse_processor import call

value = call({function_name})
if value: print(value)
"""
            )

        # chmod
        system(f"chmod +x {output_path}/{function_name}")


def _help(function, param):
    default = f"(default: {param.default})" if param.default != inspect.Parameter.empty else ""
    function_doc = [doc for doc in function.__doc__.split(":param") if param.name in doc] if function.__doc__ else []
    doc_string = function_doc[0].split(":")[1].strip() if function_doc else ""
    return f"{doc_string} {default}"


def _type(param, to_string=False):
    t = param.annotation if param.annotation != inspect.Parameter.empty else type(
        param.default) if param.default != inspect.Parameter.empty else str
    return t.__name__ if to_string else t


# bool.__name__


def _is_first_parameter(param, function):
    return param.name == list(inspect.signature(function).parameters.keys())[
        0] if len(inspect.signature(function).parameters.keys()) > 0 else False
def _is_positional(param, function):
    return _is_first_parameter(param, function) or param.default == inspect.Parameter.empty

def _required(param, function):
    return True if \
        param.default == inspect.Parameter.empty and not (
                _is_first_parameter(param, function) or "**" not in str(function.__name__)) else False


def call(function):
    parser = argparse.ArgumentParser(prog=function.__name__, description=function.__doc__)
    for param in inspect.signature(function).parameters.values():
        # if first argument then add it as positional
        if _is_positional(param, function):
            parser.add_argument(
                f"{param.name}",
                default=param.default if param.default != inspect.Parameter.empty else None,
                type=_type(param),
                nargs=argparse.OPTIONAL if not _required(param, function) else argparse.ZERO_OR_MORE,
                help=_help(function, param),
                metavar=f"{param.name} {_type(param, to_string=True)}"
            )
        else:
            parser.add_argument(
                f"--{param.name}",
                default=param.default if param.default != inspect.Parameter.empty else None,
                type=_type(param),
                required=_required(param, function),
                help=_help(function, param),
                metavar=_type(param, to_string=True)
            )

    try:
        argcomplete.autocomplete(parser)
    except NameError:
        pass
    args = parser.parse_args()
    # remove inspect empty args from dict
    a = vars(args)
    # print(a)
    args = vars(args)
    args = {k: v for k, v in args.items() if v is not inspect.Parameter.empty and v is not None}
    return function(**args)


if __name__ == "__main__":
    call(generic_argparse_processor)
